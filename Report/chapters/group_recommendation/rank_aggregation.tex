\section{Rank Aggregation}\label{sec:rank_aggregation}
Having a ranked list for each user in a group it is then possible to aggregate them together in order to get a group recommendation. We took base in the voting approach call borda count and together with the basic borda count method, which can seen represented in pseudocode in Listing \ref{lst:BC}, we have constructed different variations thereof. 
\subsection{Borda Count}
In Listing \ref{lst:BC} is pseudo implementation of our Borda Count(BC) method. It takes a matrix for the top-k preferences of users in a group as input and returns an array of ranked items which is the group recommendations. 

We wanted to use the indexes in the top-k matrix as our scoring system. In order to do so we had to reverse the top-k matrix as it is sorted in descending order which results in a users top preference being at index 1 which only gives 1 vote instead of k votes at index k. Next we had to find each unique item across all for the users since we need to calculate the score of each distinct item.

from Line 8-16 we then iterate through the list of unique items in order to calculate a score for each of them. We do so by going though each user, starting at Line 10, to see if the item is on their list and if so adds its index position to its score value. The scores are stored in an array where their index matches the item they represent in the list of unique items, this happens in Line 15.

When the score is found for each item we had to find the top-k we wanted to return. This is done form Line 18-22. Matlab have a function to find the largest item in a array which can return both the value and index. We iterated though the list of scores to find the index of the largest score. Each time we iterated though we would use the index to lookup items and add them to the result list and we then would set the largest score to be zero in order to find the next score. 
\begin{lstlisting}[caption={Borda count implementation},label=lst:BC,escapechar=|]
input: A matrix topK containing users individual ranked preferences.
output: An array with the recommendations for the group in a ranked order.

topK = reverse(topK)
items = unique(topK)
users = number of rows in topK

for i = 1 to size(items)
	score = 0
	for j = 1 to users
		if movie(i) \in topK(j,:)
			score += position of item(i) in array topK(j,:) |\label{line:sumscores}|
		end
	end
	scores(i) = score
end

for i = 1 to returnSize
	I = index of highest value in scores
	scores(I) = 0
	result(i) = movies(I)
end

return results

\end{lstlisting}

\subsection{Borda Weighted Count}
Borda Weighted Count(BWC) is almost identical with the BC in Listing \ref{lst:BC}. The only difference is in Line \ref{line:sumweighted}, where we, in addition to adding the score to the array of scores, adds a weight to the score equal to how many times the item related to the score appease in the top-k matrix.

\begin{lstlisting}[caption={Borda weighted count implementation},label=lst:BWC, firstnumber=7,escapechar=|]
...
for i = 1 to size(items)
	score = 0
	for j = 1 to users
		if movie(i) is in topK(j,:)
			score += position of movie(i) in array topK(j,:)
		end
	end
	scores(i) = score + number of times the item appears in the topK-matrix |\label{line:sumweighted}|
end
...
\end{lstlisting}
\subsection{Borda Escalating Count}
As for BWT, Borda Escalating Count(BEC) is very similar to BC. In BEC we split the items into three categories which is bot, mid and top. We define bot and mid in Line \ref{line:bot} and \ref{line:mid}. bot gets the size equal to 1/3 of column size of top-k, mid gets 2/3, and top is not defined it is those above the mid. We use these values to assign an additional weight to each users items depending on their rank. In Line \ref{line:top} one can see that a weight on 3 is added to items with index above the middle threshold. If the index is between the mid and bot thresholds it gets the weight 1 and nothing if it is below bot threshold.
\begin{lstlisting}[caption={Borda escalating count implementation},label=lst:BEC, firstnumber=7,escapechar=|]
...
k = number of columns in topK
bot = k/3 		|\label{line:bot}|
mid = top + k/3	|\label{line:mid}|

for i = 1 to size(items)
	score = 0
	for j = 1 to users
		if movie(i) is in topK(j,:)
			index = position of item(i) in array topK(j,:)
			score += index
			if index > mid			
               score = score + 3	|\label{line:top}|
           	elseif index > bot and mid < index
               score = score + 1
           end 
		end
	end
	scores(i) = score
end
...
\end{lstlisting}

\subsection{Borda Transferable Count} \label{sec:BTC}
The last method we decided to try is Borda Transferable Count(BTC). This is a somewhat more comprehensive modification of the BC method the base implementation is the same because the initial scores are assigned the same way as can be seen in Listing \ref{lst:BTC}. The difference between this version and the original is that instead of ignoring the votes for scores that did not get selected, this version redistributes them to see if it would make a difference on the return list.

The first differences is that we renames the top-k list to topKItems and then creates a new matrix over the vote distribution from the users in Line 4-9. Then everything is as usual until we reach Line \ref{line:transfer}. Here we created a loop that for each item i items list we call the transferVotes function which can be seen in Listing \ref{lst:BTCtransfer}


\begin{lstlisting}[caption={Borda transferable count implementation},label=lst:BTC]
items = unique(topK)
users = number of rows in topK
topKItems = revert(topK)
topKVotes = size(topKItems);
for i=1:row
    for j=1:col
        topKVotes(i,j)=j;
    end 
end

for i = 1 to size(items)
	score = 0
	for j = 1 to users
		if movie(i) is in topK(j,:)
			score += position of item(i) in array topK(j,:)
		end
	end
	scores(i) = score
end

for i = 1 to size(items)	|\label{line:transfer}|
	[result, scores, items, topKItems, topKVotes] = transferVotes(result, scores, items, topKItems, topKVotes)
end
	
...
\end{lstlisting}

The transferVote function is where we redistribute votes. There are two scenarios in which we need to transfer votes. The first scenario starts on Line \ref{line:highest} and states that if highestScore value exceeds a threshold the item related to that score is added to the result list. We then find the difference between the highestScore and the threshold and saves it in the transfer variable because these votes needs to be redistributed in order for them not to be wasted. In Lines 10-15 we find the list of users that voted on the highScore item  called votingUsers together with what they voted on it in list usersVotes. Next in Lines 17-23 we make at the redistribution for the votes by iterating though votingUsers in order to find the the items each user want to vote on instead. We select this item strategically be choosing the item closest to reaching the threshold instead of voting on a users favourite item. We do this based on a theory that getting as much as possible on the group recommendation list gives more satisfaction than just getting their favourite item on. When we have fund the item on a users top-k closest to the threshold we update the items score in Line \ref{line:scoreupdate} by adding a percentage of the votes for redistribution based on the users original vote compared to the other users. \note{omformuler den sidste sÃ¦tning!} After updating the score the topKVoting matrix is updated with the redistribution. Lastly the highestScore item is removed for the scores and items list. 

The second case is if no item reaches the threshold in which case we select the lowest scored item and redistributes its votes in the same manner as above. We continue switching between these cases until we have the items we need either by having reached the return size with items above the threshold or until the combined result and items list have the same size as return size.

\begin{lstlisting}[caption={Implementation for the transfer method},label=lst:BTCtransfer]
users = rows in topkItems
threshold = summation of all votes divided with the return size
highestScore = highest value in scores

if highestScore > threshold |\label{line:highest}|
	result = highestScore
	transfer = highestScore - threshold
	votingUsers = []
	usersVotes = []
	for i = 1 to users 
		if they voted on highestScore
			votingUsers += users(i)
			usersVotes += highestScore index in topKVotes
		end
	end
		
	for i = 1 to size(votingUsers)
		for j = 1 to column of topKItems
			highest = the user item with most votes in the group
		end
		scores(index of highest) += transfer * (usersVotes(i)/sum(votingUsers)) |\label{line:scoreupdate}|
		update topKVoting with the new vote distribution 
	end
	
  scores(index of highestScore) = [];
  items(index of highestScore) = [];
	
elseif size(result) + size(items) > returnSize
	This part is almost as of highestScore just for the lowestScore.
end

\end{lstlisting}